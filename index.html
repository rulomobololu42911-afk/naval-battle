<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naval Commander</title>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #2d3748 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(0, 150, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 150, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 100, 0, 0.06) 0%, transparent 50%);
            animation: backgroundShift 20s ease-in-out infinite;
            z-index: -1;
        }
        @keyframes backgroundShift {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        .logo {
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #0099cc, #0066aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
            animation: logoGlow 3s ease-in-out infinite alternate;
        }
        @keyframes logoGlow {
            from { filter: drop-shadow(0 0 10px rgba(0, 212, 255, 0.3)); }
            to { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.6)); }
        }
        .subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 40px;
            font-weight: 300;
        }
        .balance-display {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 193, 7, 0.1));
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 40px;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);
        }
        .balance-amount {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .game-modes {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 400px;
        }
        .mode-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        .mode-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.8s;
        }
        .mode-card:hover::before {
            left: 100%;
        }
        .mode-card:hover {
            transform: translateY(-5px);
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 15px 35px rgba(0, 212, 255, 0.2);
        }
        .mode-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            display: block;
        }
        .mode-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: #ffffff;
        }
        .mode-desc {
            color: #94a3b8;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        .bet-screen, .create-room-screen, .waiting-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        .bet-title {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .bet-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 20px;
            margin: 30px 0;
            width: 100%;
            max-width: 500px;
        }
        .bet-option {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 16px;
            padding: 20px;
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        .bet-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.4);
        }
        .bet-option.selected {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }
        .setup-screen {
            display: none;
            padding: 20px 0;
        }
        .setup-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .setup-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #00d4ff;
        }
        .fleet-selection {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .ship-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border: none;
            border-radius: 12px;
            padding: 12px 16px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .ship-btn.completed {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        .ship-btn.selected {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
        }
        .setup-board {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 25px;
            margin: 20px auto;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            max-width: 320px;
            margin: 0 auto;
        }
        .cell {
            aspect-ratio: 1;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            position: relative;
            background: rgba(255,255,255,0.03);
        }
        .cell:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: scale(1.05);
        }
        .cell.ship {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        .cell.hit {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            animation: hitEffect 0.6s ease;
        }
        .cell.hit::after {
            content: 'üí•';
            animation: explosion 0.8s ease;
        }
        .cell.miss {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            animation: missEffect 0.4s ease;
        }
        .cell.miss::after {
            content: 'üíß';
        }
        .cell.sunk {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            box-shadow: 0 0 20px rgba(108, 92, 231, 0.6);
        }
        .cell.sunk::after {
            content: '‚ò†Ô∏è';
        }
        .cell.blocked {
            background: rgba(255, 255, 255, 0.1);
            opacity: 0.5;
        }
        @keyframes hitEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: #ff3838; }
            100% { transform: scale(1); }
        }
        @keyframes missEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes explosion {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .game-screen {
            display: none;
            padding: 20px 0;
        }
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .game-status {
            font-size: 1.1rem;
            font-weight: 600;
            padding: 12px 20px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 153, 204, 0.2));
            border-radius: 25px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        .game-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }
        .game-boards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }
        @media (max-width: 768px) {
            .game-boards {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        .board-container {
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .board-title {
            text-align: center;
            margin-bottom: 15px;
            font-weight: 700;
            font-size: 1.2rem;
            color: #00d4ff;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            padding: 14px 28px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            margin: 5px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled {
            background: linear-gradient(135deg, #64748b, #475569);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.3);
        }
        .btn-primary:hover {
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }
        .btn-secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
        }
        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .coming-soon-text {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-top: 10px;
            opacity: 0.7;
        }
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .result-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 25px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255,255,255,0.1);
        }
        .result-title {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 20px;
        }
        .result-title.win {
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        .result-title.lose {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        @media (max-width: 480px) {
            .container { padding: 10px; }
            .logo { font-size: 2.5rem; }
            .board { max-width: 280px; gap: 2px; }
            .cell { font-size: 1rem; }
            .game-header { flex-direction: column; text-align: center; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- –°–¢–ê–†–¢–û–í–´–ô –≠–ö–†–ê–ù -->
        <div class="start-screen" id="startScreen">
            <h1 class="logo">‚öì NAVAL COMMANDER</h1>
            <p class="subtitle">–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –º–æ—Ä—Å–∫–∏–µ —Å—Ä–∞–∂–µ–Ω–∏—è</p>
            <div class="balance-display">
                <div style="color: #94a3b8; margin-bottom: 5px;">–í–∞—à –±–∞–ª–∞–Ω—Å</div>
                <div class="balance-amount" id="balanceAmount">–ó–∞–≥—Ä—É–∑–∫–∞... üç¨</div>
            </div>
            <div class="game-modes">
                <div class="mode-card" onclick="selectGameMode('friend')">
                    <span class="mode-icon">üë•</span>
                    <div class="mode-title">–°—Ä–∞–∂–µ–Ω–∏–µ —Å –¥—Ä—É–≥–æ–º</div>
                    <div class="mode-desc">–ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ —Å—Ä–∞–∑–∏—Ç–µ—Å—å –≤ —á–µ—Å—Ç–Ω–æ–º –ø–æ–µ–¥–∏–Ω–∫–µ</div>
                </div>
                <div class="mode-card" onclick="selectGameMode('ai')">
                    <span class="mode-icon">ü§ñ</span>
                    <div class="mode-title">–ü—Ä–æ—Ç–∏–≤ –ò–ò</div>
                    <div class="mode-desc">–°—Ä–∞–∑–∏—Ç–µ—Å—å —Å —É–º–Ω—ã–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–æ–º</div>
                </div>
                <div class="mode-card" onclick="selectGameMode('online')">
                    <span class="mode-icon">üåê</span>
                    <div class="mode-title">–û–Ω–ª–∞–π–Ω –±–∏—Ç–≤–∞</div>
                    <div class="mode-desc">–ù–∞–π–¥–∏—Ç–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ø–æ –≤—Å–µ–º—É –º–∏—Ä—É</div>
                </div>
                <p class="coming-soon-text">–û–Ω–ª–∞–π–Ω —Ä–µ–∂–∏–º –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–∑–∂–µ!</p>
            </div>
        </div>

        <!-- –≠–ö–†–ê–ù –°–¢–ê–í–û–ö (–¥–ª—è –ò–ò –∏ PvP) -->
        <div class="bet-screen" id="betScreen">
            <h2 class="bet-title">üí∞ –†–∞–∑–º–µ—Ä —Å—Ç–∞–≤–∫–∏</h2>
            <p style="color: #94a3b8; margin-bottom: 20px;">–í—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É –¥–ª—è —É—á–∞—Å—Ç–∏—è –≤ —Å—Ä–∞–∂–µ–Ω–∏–∏</p>
            <div class="balance-display">
                <div style="color: #94a3b8; margin-bottom: 5px;">–î–æ—Å—Ç—É–ø–Ω–æ</div>
                <div class="balance-amount" id="betBalanceAmount">–ó–∞–≥—Ä—É–∑–∫–∞... üç¨</div>
            </div>
            <div class="bet-options">
                <button class="bet-option" onclick="selectBet(1000)">1,000 üç¨</button>
                <button class="bet-option" onclick="selectBet(2500)">2,500 üç¨</button>
                <button class="bet-option" onclick="selectBet(5000)">5,000 üç¨</button>
                <button class="bet-option" onclick="selectBet(10000)">10,000 üç¨</button>
            </div>
            <div class="controls">
                <button class="btn btn-primary" id="confirmBetBtn" onclick="confirmBet()" disabled>üéØ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Å—Ç–∞–≤–∫—É</button>
                <button class="btn btn-secondary" onclick="showScreen('startScreen')">‚óÄÔ∏è –ù–∞–∑–∞–¥</button>
            </div>
        </div>

        <!-- –≠–ö–†–ê–ù –°–û–ó–î–ê–ù–ò–Ø –ö–û–ú–ù–ê–¢–´ -->
        <div class="create-room-screen" id="createRoomScreen">
            <h2>üë• –°–æ–∑–¥–∞—Ç—å PvP-–∫–æ–º–Ω–∞—Ç—É</h2>
            <p>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞–≤–∫—É –¥–ª—è —Å—Ä–∞–∂–µ–Ω–∏—è —Å –¥—Ä—É–≥–æ–º</p>
            <div class="balance-display">
                <div style="color: #94a3b8; margin-bottom: 5px;">–î–æ—Å—Ç—É–ø–Ω–æ</div>
                <div class="balance-amount" id="multiBalanceAmount">–ó–∞–≥—Ä—É–∑–∫–∞... üç¨</div>
            </div>
            <div class="bet-options">
                <button class="bet-option" onclick="selectBetMP(1000)">1,000 üç¨</button>
                <button class="bet-option" onclick="selectBetMP(2500)">2,500 üç¨</button>
                <button class="bet-option" onclick="selectBetMP(5000)">5,000 üç¨</button>
                <button class="bet-option" onclick="selectBetMP(10000)">10,000 üç¨</button>
            </div>
            <button class="btn btn-primary" id="createRoomBtn" onclick="createRoom()" disabled>–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
            <button class="btn" onclick="showScreen('startScreen')">‚óÄÔ∏è –ù–∞–∑–∞–¥</button>
        </div>

        <!-- –û–ñ–ò–î–ê–ù–ò–ï –ü–†–û–¢–ò–í–ù–ò–ö–ê -->
        <div class="waiting-screen" id="waitingForOpponentScreen">
            <h2>‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</h2>
            <p>–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã: <span id="roomCodeDisplay" style="font-size:2rem; font-weight:bold; color:#ffd700;"></span></p>
            <p>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–¥ –¥—Ä—É–≥—É!</p>
            <button class="btn btn-secondary" onclick="cancelRoom()">–û—Ç–º–µ–Ω–∏—Ç—å</button>
        </div>

        <!-- –†–ê–°–°–¢–ê–ù–û–í–ö–ê -->
        <div class="setup-screen" id="setupScreen">
            <div class="setup-header">
                <h2 class="setup-title">üö¢ –†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–æ—Ç–∞</h2>
                <p style="color: #94a3b8;">–†–∞–∑–º–µ—Å—Ç–∏—Ç–µ –∫–æ—Ä–∞–±–ª–∏ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º –ø–æ–ª–µ</p>
            </div>
            <div class="fleet-selection">
                <button class="ship-btn selected" data-ship="4" onclick="selectShip(4)">‚öì –õ–∏–Ω–∫–æ—Ä (4)</button>
                <button class="ship-btn" data-ship="3" onclick="selectShip(3)">üö¢ –ö—Ä–µ–π—Å–µ—Ä (3) x2</button>
                <button class="ship-btn" data-ship="2" onclick="selectShip(2)">‚õµ –≠—Å–º–∏–Ω–µ—Ü (2) x3</button>
                <button class="ship-btn" data-ship="1" onclick="selectShip(1)">üõ•Ô∏è –ö–∞—Ç–µ—Ä (1) x4</button>
            </div>
            <div class="setup-board">
                <div class="board" id="setupBoard"></div>
            </div>
            <div class="controls">
                <button class="btn" onclick="toggleOrientation()">üîÑ <span id="orientationText">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ</span></button>
                <button class="btn" onclick="randomPlacement()">üé≤ –°–ª—É—á–∞–π–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞</button>
                <button class="btn btn-primary" onclick="startBattle()" id="startBattleBtn" disabled>‚öîÔ∏è –í –±–æ–π!</button>
            </div>
        </div>

        <!-- –ò–ì–†–ê -->
        <div class="game-screen" id="gameScreen">
            <div class="game-header">
                <div class="game-status" id="gameStatus">–í–∞—à —Ö–æ–¥! –í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å</div>
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="playerShips">10</div>
                        <div class="stat-label">–í–∞—à–∏ –∫–æ—Ä–∞–±–ª–∏</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="enemyShips">10</div>
                        <div class="stat-label">–ö–æ—Ä–∞–±–ª–∏ –≤—Ä–∞–≥–∞</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="gameShots">0</div>
                        <div class="stat-label">–í—ã—Å—Ç—Ä–µ–ª–æ–≤</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="gameAccuracy">0%</div>
                        <div class="stat-label">–¢–æ—á–Ω–æ—Å—Ç—å</div>
                    </div>
                </div>
            </div>
            <div class="game-boards">
                <div class="board-container">
                    <div class="board-title">üõ°Ô∏è –í–∞—à —Ñ–ª–æ—Ç</div>
                    <div class="board" id="playerBoard"></div>
                </div>
                <div class="board-container">
                    <div class="board-title">üéØ –§–ª–æ—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</div>
                    <div class="board" id="enemyBoard"></div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-secondary" onclick="surrenderGame()">üè≥Ô∏è –°–¥–∞—Ç—å—Å—è</button>
                <button class="btn" onclick="showScreen('startScreen')">üè† –í –º–µ–Ω—é</button>
            </div>
        </div>
    </div>

    <!-- –ú–û–î–ê–õ–¨–ù–û–ï –û–ö–ù–û –†–ï–ó–£–õ–¨–¢–ê–¢–ê -->
    <div class="result-modal" id="resultModal">
        <div class="result-content">
            <h2 class="result-title" id="resultTitle">üèÜ –ü–æ–±–µ–¥–∞!</h2>
            <p id="resultText">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø–æ—Ç–æ–ø–∏–ª–∏ –≤–µ—Å—å –≤—Ä–∞–∂–µ—Å–∫–∏–π —Ñ–ª–æ—Ç!</p>
            <div id="resultReward" style="margin: 20px 0; font-size: 1.5rem; font-weight: bold; color: #ffd700;"></div>
            <div class="controls">
                <button class="btn btn-primary" onclick="newGame()">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                <button class="btn" onclick="showScreen('startScreen')">üè† –í –º–µ–Ω—é</button>
            </div>
        </div>
    </div>

    <script>
        // === WebSocket ===
        const socket = io('http://46.149.69.215:3000');
        let currentRoomCode = null;
        let isMultiplayer = false;
        let mySocketId = null;
        let myBoard = null;
        let opponentBoard = Array(8).fill().map(() => Array(8).fill(0));

        // === Telegram ID ===
        let telegramUserId = null;
        if (window.Telegram?.WebApp?.initDataUnsafe?.user?.id) {
            telegramUserId = window.Telegram.WebApp.initDataUnsafe.user.id;
        } else {
            telegramUserId = 123456789;
        }

        // === –ë–∞–ª–∞–Ω—Å ===
        async function loadBalanceFromServer() {
            if (!telegramUserId) return 10000;
            try {
                const res = await fetch(`http://46.149.69.215:3000/api/balance?telegram_id=${telegramUserId}`);
                const data = await res.json();
                return data.balance || 10000;
            } catch (e) {
                console.error('Failed to load balance', e);
                return 10000;
            }
        }

        async function saveBalanceToServer(balance) {
            if (!telegramUserId) return;
            try {
                await fetch('http://46.149.69.215:3000/api/balance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ telegram_id: telegramUserId, balance })
                });
            } catch (e) {
                console.error('Failed to save balance', e);
            }
        }

        // === –û–°–ù–û–í–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let currentScreen = 'startScreen';
        let gameMode = '';
        let selectedBet = 0;
        let gamePhase = 'setup';
        let currentPlayer = 'player';
        let selectedShipSize = 4;
        let isHorizontal = true;
        let shipsToPlace = {4: 1, 3: 2, 2: 3, 1: 4};
        let placedShips = {4: 0, 3: 0, 2: 0, 1: 0};
        let aiMode = 'search';
        let aiLastHit = null;
        let aiTarget = [];
        let playerBalance = 10000;
        let playerBoard = Array(8).fill().map(() => Array(8).fill(0));
        let enemyBoard = Array(8).fill().map(() => Array(8).fill(0));
        let playerShots = Array(8).fill().map(() => Array(8).fill(0));
        let enemyShots = Array(8).fill().map(() => Array(8).fill(0));
        let playerShipCells = [];
        let enemyShipCells = [];
        let gameStats = {
            shots: 0,
            hits: 0,
            playerShipsAlive: 10,
            enemyShipsAlive: 10
        };

        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
        async function initGame() {
            playerBalance = await loadBalanceFromServer();
            updateBalance();
            showScreen('startScreen');
        }

        function showScreen(screenId) {
            document.querySelectorAll('.start-screen, .bet-screen, .setup-screen, .game-screen, .create-room-screen, .waiting-screen').forEach(screen => {
                screen.style.display = 'none';
            });
            document.getElementById(screenId).style.display = ['startScreen', 'betScreen', 'createRoomScreen', 'waitingForOpponentScreen'].includes(screenId) ? 'flex' : 'block';
            currentScreen = screenId;
        }

        // === –†–ï–ñ–ò–ú–´ –ò–ì–†–´ ===
        function selectGameMode(mode) {
            if (mode === 'online') {
                alert('–†–µ–∂–∏–º "–û–Ω–ª–∞–π–Ω –±–∏—Ç–≤–∞" –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–∑–∂–µ!');
                return;
            }
            gameMode = mode;
            if (mode === 'friend') {
                isMultiplayer = true;
                showScreen('createRoomScreen');
                document.getElementById('multiBalanceAmount').textContent = `${playerBalance.toLocaleString()} üç¨`;
            } else {
                isMultiplayer = false;
                showScreen('betScreen');
            }
        }

        function selectBet(amount) {
            if (amount > playerBalance) return;
            selectedBet = amount;
            document.querySelectorAll('.bet-option').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            document.getElementById('confirmBetBtn').disabled = false;
        }

        function selectBetMP(amount) {
            if (amount > playerBalance) return;
            selectedBet = amount;
            document.querySelectorAll('.bet-option').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            document.getElementById('createRoomBtn').disabled = false;
        }

        function confirmBet() {
            if (selectedBet === 0 || selectedBet > playerBalance) return;
            showScreen('setupScreen');
            initSetup();
        }

        function createRoom() {
            if (selectedBet === 0 || selectedBet > playerBalance) return;
            socket.emit('create-room', { telegramId: telegramUserId, bet: selectedBet });
        }

        function cancelRoom() {
            showScreen('startScreen');
        }

        // === –°–û–ö–ï–¢ –°–û–ë–´–¢–ò–Ø ===
        socket.on('connect', () => {
            mySocketId = socket.id;
        });

        socket.on('room-created', (data) => {
            currentRoomCode = data.code;
            document.getElementById('roomCodeDisplay').textContent = data.code;
            showScreen('waitingForOpponentScreen');
        });

        socket.on('opponent-joined', () => {
            showScreen('betScreen');
            document.getElementById('confirmBetBtn').style.display = 'none';
            document.querySelector('.bet-options').style.display = 'none';
            document.getElementById('betBalanceAmount').textContent = `${selectedBet.toLocaleString()} üç¨`;
            setTimeout(() => confirmBet(), 1000);
        });

        socket.on('joined-room', (data) => {
            currentRoomCode = data.code;
            selectedBet = data.bet;
            showScreen('setupScreen');
            initSetup();
        });

        socket.on('game-started', (data) => {
            gamePhase = 'playing';
            currentPlayer = (mySocketId === data.turn) ? 'player' : 'enemy';
            showScreen('gameScreen');
            createGameBoards();
            updateGameStatus(currentPlayer === 'player' ? '–í–∞—à —Ö–æ–¥!' : '–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...');
        });

        socket.on('move-made', (data) => {
            const { by, row, col, hit, turn } = data;
            if (by !== mySocketId) {
                enemyShots[row][col] = hit ? 2 : 1;
                updateBoardDisplay('playerBoard');
                gameStats.shots++;
                if (hit) gameStats.hits++;
                updateGameStats();
            }
            currentPlayer = (mySocketId === turn) ? 'player' : 'enemy';
            updateGameStatus(currentPlayer === 'player' ? '–í–∞—à —Ö–æ–¥!' : '–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...');
        });

        socket.on('game-over', (data) => {
            if (data.winner === mySocketId) {
                endGame('win');
            } else {
                endGame('lose');
            }
        });

        socket.on('error', (data) => {
            alert(data.message);
            showScreen('startScreen');
        });

        socket.on('opponent-disconnected', () => {
            alert('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è. –°—Ç–∞–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞.');
            playerBalance += selectedBet;
            updateBalance();
            saveBalanceToServer(playerBalance);
            showScreen('startScreen');
        });

        // === –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) ===
        function initSetup() {
            createSetupBoard();
            if (!isMultiplayer) generateEnemyFleet();
            resetShipPlacement();
        }

        function createSetupBoard() {
            const board = document.getElementById('setupBoard');
            board.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.onclick = () => placeShip(i, j);
                    board.appendChild(cell);
                }
            }
        }

        function placeShip(row, col) {
            if (placedShips[selectedShipSize] >= shipsToPlace[selectedShipSize]) return;
            if (canPlaceShip(row, col, selectedShipSize, isHorizontal)) {
                const shipCells = [];
                for (let i = 0; i < selectedShipSize; i++) {
                    const newRow = isHorizontal ? row : row + i;
                    const newCol = isHorizontal ? col + i : col;
                    playerBoard[newRow][newCol] = selectedShipSize;
                    shipCells.push({row: newRow, col: newCol});
                }
                playerShipCells.push(shipCells);
                placedShips[selectedShipSize]++;
                updateSetupBoard();
                updateShipButtons();
                autoSelectNextShip();
                if (allShipsPlaced()) {
                    document.getElementById('startBattleBtn').disabled = false;
                }
            }
        }

        function canPlaceShip(row, col, size, horizontal) {
            for (let i = 0; i < size; i++) {
                const newRow = horizontal ? row : row + i;
                const newCol = horizontal ? col + i : col;
                if (newRow >= 8 || newCol >= 8) return false;
                if (playerBoard[newRow][newCol] !== 0) return false;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const checkRow = newRow + dr;
                        const checkCol = newCol + dc;
                        if (checkRow >= 0 && checkRow < 8 && checkCol >= 0 && checkCol < 8) {
                            if (playerBoard[checkRow][checkCol] !== 0) return false;
                        }
                    }
                }
            }
            return true;
        }

        function toggleOrientation() {
            isHorizontal = !isHorizontal;
            document.getElementById('orientationText').textContent = isHorizontal ? '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ' : '–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ';
        }

        function randomPlacement() {
            resetPlayerBoard();
            const ships = [4, 3, 3, 2, 2, 2, 1, 1, 1, 1];
            for (let ship of ships) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 100) {
                    const row = Math.floor(Math.random() * 8);
                    const col = Math.floor(Math.random() * 8);
                    const horizontal = Math.random() > 0.5;
                    if (canPlaceShip(row, col, ship, horizontal)) {
                        const shipCells = [];
                        for (let i = 0; i < ship; i++) {
                            const newRow = horizontal ? row : row + i;
                            const newCol = horizontal ? col + i : col;
                            playerBoard[newRow][newCol] = ship;
                            shipCells.push({row: newRow, col: newCol});
                        }
                        playerShipCells.push(shipCells);
                        placedShips[ship]++;
                        placed = true;
                    }
                    attempts++;
                }
            }
            updateSetupBoard();
            updateShipButtons();
            document.getElementById('startBattleBtn').disabled = false;
        }

        function generateEnemyFleet() {
            enemyBoard = Array(8).fill().map(() => Array(8).fill(0));
            enemyShipCells = [];
            const ships = [4, 3, 3, 2, 2, 2, 1, 1, 1, 1];
            ships.sort(() => Math.random() - 0.5);
            for (let shipSize of ships) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 500) { 
                    const row = Math.floor(Math.random() * 8);
                    const col = Math.floor(Math.random() * 8);
                    const horizontal = Math.random() > 0.5;
                    if (canPlaceEnemyShip(row, col, shipSize, horizontal)) {
                        const shipCells = [];
                        for (let i = 0; i < shipSize; i++) {
                            const newRow = horizontal ? row : row + i;
                            const newCol = horizontal ? col + i : col;
                            enemyBoard[newRow][newCol] = shipSize;
                            shipCells.push({row: newRow, col: newCol});
                        }
                        enemyShipCells.push(shipCells);
                        placed = true;
                    }
                    attempts++;
                }
            }
        }

        function canPlaceEnemyShip(row, col, size, horizontal) {
            for (let i = 0; i < size; i++) {
                const newRow = horizontal ? row : row + i;
                const newCol = horizontal ? col + i : col;
                if (newRow >= 8 || newCol >= 8) return false;
                if (enemyBoard[newRow][newCol] !== 0) return false;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const checkRow = newRow + dr;
                        const checkCol = newCol + dc;
                        if (checkRow >= 0 && checkRow < 8 && checkCol >= 0 && checkCol < 8) {
                            if (enemyBoard[checkRow][checkCol] !== 0) return false;
                        }
                    }
                }
            }
            return true;
        }

        function startBattle() {
            if (!allShipsPlaced()) return;
            myBoard = JSON.parse(JSON.stringify(playerBoard));
            if (isMultiplayer) {
                socket.emit('player-ready', { code: currentRoomCode, board: myBoard });
                gamePhase = 'waiting';
                showScreen('gameScreen');
                createGameBoards();
                updateGameStatus('–û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...');
            } else {
                gamePhase = 'playing';
                currentPlayer = 'player';
                gameStats = {shots: 0, hits: 0, playerShipsAlive: 10, enemyShipsAlive: 10};
                showScreen('gameScreen');
                createGameBoards();
                updateGameStats();
                updateGameStatus('–í–∞—à —Ö–æ–¥! –í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –Ω–∞ –ø–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞');
            }
        }

        function createGameBoards() {
            createBoard('playerBoard', true);
            createBoard('enemyBoard', false);
        }

        function createBoard(boardId, isPlayerBoard) {
            const board = document.getElementById(boardId);
            board.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    if (!isPlayerBoard && !isMultiplayer) {
                        cell.onclick = () => playerShoot(i, j);
                    }
                    board.appendChild(cell);
                }
            }
            updateBoardDisplay(boardId);
        }

        function playerShoot(row, col) {
            if (isMultiplayer) {
                if (gamePhase !== 'playing' || currentPlayer !== 'player') return;
                if (playerShots[row][col] !== 0) return;
                socket.emit('make-move', { code: currentRoomCode, row, col });
                playerShots[row][col] = 1;
                updateBoardDisplay('enemyBoard');
                currentPlayer = 'enemy';
                updateGameStatus('–•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...');
            } else {
                if (gamePhase !== 'playing' || currentPlayer !== 'player') return;
                if (playerShots[row][col] !== 0) return;
                gameStats.shots++;
                const hit = enemyBoard[row][col] > 0;
                playerShots[row][col] = hit ? 2 : 1;
                if (hit) {
                    gameStats.hits++;
                    const sunkShip = checkSunkShip(row, col, enemyShipCells, playerShots);
                    if (sunkShip) {
                        gameStats.enemyShipsAlive--;
                        markSurroundingCells(sunkShip, playerShots);
                        updateGameStatus('üí• –ö–æ—Ä–∞–±–ª—å –ø–æ—Ç–æ–ø–ª–µ–Ω! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Å—Ç—Ä–µ–ª—å–±—É');
                    } else {
                        updateGameStatus('üéØ –ü–æ–ø–∞–¥–∞–Ω–∏–µ! –í–∞—à —Ö–æ–¥ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è');
                    }
                    if (gameStats.enemyShipsAlive === 0) {
                        endGame('win');
                        return;
                    }
                } else {
                    updateGameStatus('üíß –ü—Ä–æ–º–∞—Ö. –•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞');
                    currentPlayer = 'enemy';
                    setTimeout(enemyTurn, 1500);
                }
                updateBoardDisplay('enemyBoard');
                updateGameStats();
            }
        }

        function enemyTurn() {
            if (gameMode !== 'ai' || gamePhase !== 'playing') return;
            let row, col;
            if (aiMode === 'hunt' && aiTarget.length > 0) {
                let target = aiTarget.shift();
                while (target && enemyShots[target.r][target.c] !== 0) {
                    target = aiTarget.shift();
                }
                if (target) {
                    row = target.r;
                    col = target.c;
                } else {
                    aiMode = 'search';
                }
            }
            if (aiMode === 'search') {
                do {
                    row = Math.floor(Math.random() * 8);
                    col = Math.floor(Math.random() * 8);
                } while (enemyShots[row][col] !== 0);
            }
            const hit = playerBoard[row][col] > 0;
            enemyShots[row][col] = hit ? 2 : 1;
            updateBoardDisplay('playerBoard');
            if (hit) {
                aiLastHit = {row, col};
                const sunkShip = checkSunkShip(row, col, playerShipCells, enemyShots);
                if (sunkShip) {
                    aiMode = 'search';
                    aiTarget = [];
                    gameStats.playerShipsAlive--;
                    markSurroundingCells(sunkShip, enemyShots);
                    updateGameStatus('üî• –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ—Ç–æ–ø–∏–ª –≤–∞—à –∫–æ—Ä–∞–±–ª—å!');
                    if (gameStats.playerShipsAlive === 0) {
                        endGame('lose');
                    } else {
                        setTimeout(enemyTurn, 1000);
                    }
                } else {
                    aiMode = 'hunt';
                    updateGameStatus('üí• –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–ø–∞–ª! –û–Ω —Å—Ç—Ä–µ–ª—è–µ—Ç –µ—â–µ —Ä–∞–∑');
                    const neighbors = [
                        {r: row - 1, c: col},
                        {r: row + 1, c: col},
                        {r: row, c: col - 1},
                        {r: row, c: col + 1}
                    ];
                    for(let cell of neighbors) {
                        if(cell.r >= 0 && cell.r < 8 && cell.c >= 0 && cell.c < 8 && enemyShots[cell.r][cell.c] === 0) {
                            aiTarget.push(cell);
                        }
                    }
                    setTimeout(enemyTurn, 1000);
                }
            } else {
                updateGameStatus('üéØ –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø—Ä–æ–º–∞—Ö–Ω—É–ª—Å—è. –í–∞—à —Ö–æ–¥!');
                currentPlayer = 'player';
            }
            updateGameStats();
        }

        function checkSunkShip(hitRow, hitCol, shipCells, shots) {
            for (let ship of shipCells) {
                const hitCell = ship.find(cell => cell.row === hitRow && cell.col === hitCol);
                if (hitCell) {
                    const allHit = ship.every(cell => shots[cell.row][cell.col] === 2);
                    if (allHit) {
                        return ship;
                    }
                    break;
                }
            }
            return null;
        }

        function markSurroundingCells(shipCells, shots) {
            for (let cell of shipCells) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const newRow = cell.row + dr;
                        const newCol = cell.col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (shots[newRow][newCol] === 0) {
                                shots[newRow][newCol] = 1;
                            }
                        }
                    }
                }
            }
        }

        function updateBoardDisplay(boardId) {
            const isPlayerBoard = boardId === 'playerBoard';
            const board = isPlayerBoard ? playerBoard : (isMultiplayer ? opponentBoard : enemyBoard);
            const shots = isPlayerBoard ? enemyShots : playerShots;
            const shipCells = isPlayerBoard ? playerShipCells : enemyShipCells;
            const cells = document.querySelectorAll(`#${boardId} .cell`);
            cells.forEach((cell, index) => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.className = 'cell';
                if (shots[row][col] === 2) {
                    const sunkShip = findSunkShip(row, col, shipCells, shots);
                    if (sunkShip) {
                        cell.classList.add('sunk');
                    } else {
                        cell.classList.add('hit');
                    }
                } else if (shots[row][col] === 1) {
                    cell.classList.add('miss');
                } else if (isPlayerBoard && board[row][col] > 0) {
                    cell.classList.add('ship');
                }
            });
        }

        function findSunkShip(hitRow, hitCol, shipCells, shots) {
            for (let ship of shipCells) {
                const hitCell = ship.find(cell => cell.row === hitRow && cell.col === hitCol);
                if (hitCell) {
                    const allHit = ship.every(cell => shots[cell.row][cell.col] === 2);
                    if (allHit) {
                        return ship;
                    }
                    break;
                }
            }
            return null;
        }

        function updateGameStats() {
            document.getElementById('playerShips').textContent = gameStats.playerShipsAlive;
            document.getElementById('enemyShips').textContent = gameStats.enemyShipsAlive;
            document.getElementById('gameShots').textContent = gameStats.shots;
            const accuracy = gameStats.shots > 0 ? Math.round((gameStats.hits / gameStats.shots) * 100) : 0;
            document.getElementById('gameAccuracy').textContent = accuracy + '%';
        }

        function updateGameStatus(message) {
            document.getElementById('gameStatus').textContent = message;
        }

        function updateSetupBoard() {
            const cells = document.querySelectorAll('#setupBoard .cell');
            cells.forEach((cell, index) => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.className = 'cell';
                if (playerBoard[row][col] > 0) {
                    cell.classList.add('ship');
                }
            });
        }

        function allShipsPlaced() {
            return Object.keys(shipsToPlace).every(size => placedShips[size] === shipsToPlace[size]);
        }

        function autoSelectNextShip() {
            for (let size of [4, 3, 2, 1]) {
                if (placedShips[size] < shipsToPlace[size]) {
                    selectShip(size);
                    break;
                }
            }
        }

        function selectShip(size) {
            if (placedShips[size] >= shipsToPlace[size]) return;
            selectedShipSize = size;
            document.querySelectorAll('.ship-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-ship="${size}"]`).classList.add('selected');
        }

        function updateShipButtons() {
            document.querySelectorAll('.ship-btn').forEach(btn => {
                const size = parseInt(btn.dataset.ship);
                const remaining = shipsToPlace[size] - placedShips[size];
                if (remaining === 0) {
                    btn.classList.add('completed');
                    btn.classList.remove('selected');
                }
            });
        }

        function resetShipPlacement() {
            placedShips = {4: 0, 3: 0, 2: 0, 1: 0};
            selectedShipSize = 4;
            isHorizontal = true;
            resetPlayerBoard();
            updateSetupBoard();
            document.querySelectorAll('.ship-btn').forEach(btn => {
                btn.classList.remove('completed', 'selected');
            });
            document.querySelector('[data-ship="4"]').classList.add('selected');
            document.getElementById('startBattleBtn').disabled = true;
            document.getElementById('orientationText').textContent = '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ';
        }

        function resetPlayerBoard() {
            playerBoard = Array(8).fill().map(() => Array(8).fill(0));
            playerShipCells = [];
        }

        function endGame(result) {
            gamePhase = 'ended';
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('resultTitle');
            const text = document.getElementById('resultText');
            const reward = document.getElementById('resultReward');
            if (result === 'win') {
                title.textContent = 'üèÜ –ü–æ–±–µ–¥–∞!';
                title.className = 'result-title win';
                text.textContent = isMultiplayer ? '–í—ã –ø–æ–±–µ–¥–∏–ª–∏ –≤ PvP!' : '–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø–æ—Ç–æ–ø–∏–ª–∏ –≤–µ—Å—å –≤—Ä–∞–∂–µ—Å–∫–∏–π —Ñ–ª–æ—Ç!';
                const winnings = selectedBet * 2;
                playerBalance += winnings;
                reward.textContent = `+${winnings.toLocaleString()} üç¨`;
            } else {
                title.textContent = 'üí• –ü–æ—Ä–∞–∂–µ–Ω–∏–µ';
                title.className = 'result-title lose';
                text.textContent = isMultiplayer ? '–í–∞—Å –ø–æ–±–µ–¥–∏–ª–∏ –≤ PvP!' : '–í–∞—à —Ñ–ª–æ—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω! –¢—Ä–µ–Ω–∏—Ä—É–π—Ç–µ—Å—å –∏ –≤–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å!';
                playerBalance -= selectedBet;
                reward.textContent = `-${selectedBet.toLocaleString()} üç¨`;
            }
            updateBalance();
            saveBalanceToServer(playerBalance).then(() => {
                modal.style.display = 'flex';
            });
        }

        function surrenderGame() {
            if (confirm('–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–∞—Ç—å—Å—è?')) {
                if (isMultiplayer) {
                    socket.emit('surrender', { code: currentRoomCode });
                }
                endGame('lose');
            }
        }

        function newGame() {
            document.getElementById('resultModal').style.display = 'none';
            showScreen('startScreen');
            resetGame();
        }

        function resetGame() {
            gamePhase = 'setup';
            currentPlayer = 'player';
            gameStats = {shots: 0, hits: 0, playerShipsAlive: 10, enemyShipsAlive: 10};
            playerShots = Array(8).fill().map(() => Array(8).fill(0));
            enemyShots = Array(8).fill().map(() => Array(8).fill(0));
            resetShipPlacement();
        }

        function updateBalance() {
            document.getElementById('balanceAmount').textContent = `${playerBalance.toLocaleString()} üç¨`;
            document.getElementById('betBalanceAmount').textContent = `${playerBalance.toLocaleString()} üç¨`;
            document.getElementById('multiBalanceAmount').textContent = `${playerBalance.toLocaleString()} üç¨`;
        }

        window.addEventListener('load', () => {
            initGame();
        });
    </script>
</body>
</html>
